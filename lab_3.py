# -*- coding: utf-8 -*-
"""Лабораторная_работа_3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ICxffyWIn2UaKG8T6JPE2cVGqEJ_0jzr
"""

# --- 1. Импорт библиотек ---
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

# Настройки отображения
pd.set_option('display.max_columns', None)
sns.set(style="whitegrid")

# --- 2. Загрузка данных ---
# Пример: чтение CSV-файла
df = pd.read_csv('/content/Lab3.csv')

# --- 3. Общая информация ---
print("Размер данных:", df.shape)
print("\nТипы данных:")
print(df.dtypes)
print("\nПервые строки:")
print(df.head())

# --- 4. Проверка пропусков и дубликатов ---
print("\nПропуски в данных:")
print(df.isna().sum())

print("\nКоличество дубликатов:", df.duplicated().sum())

# --- 5. Описательная статистика ---
print("\nОсновные статистики:")
print(df.describe().T)

# --- 6. Анализ категориальных признаков ---
categorical = df.select_dtypes(include=['object', 'category']).columns
print("\nКатегориальные признаки:", list(categorical))

for col in categorical:
    print(f"\n{col} — уникальных значений: {df[col].nunique()}")
    print(df[col].value_counts().head())

# --- 7. Анализ числовых признаков ---
numerical = df.select_dtypes(include=['int64', 'float64']).columns
print("\nЧисловые признаки:", list(numerical))

# --- 8. Визуализация распределений ---
for col in numerical:
    plt.figure(figsize=(6,3))
    sns.histplot(df[col], kde=True)
    plt.title(f'Распределение: {col}')
    plt.show()

# --- 9. Корреляции ---
plt.figure(figsize=(8,6))
sns.heatmap(df.select_dtypes(include='number').corr(), annot=True, fmt=".2f", cmap="coolwarm")
plt.title("Корреляционная матрица (только числовые признаки)")
plt.show()

# --- 10. Поиск выбросов ---
for col in numerical:
    plt.figure(figsize=(6,3))
    sns.boxplot(x=df[col])
    plt.title(f'Boxplot для {col}')
    plt.show()

# --- 11. Предобработка данных для кластеризации ---
from sklearn.preprocessing import StandardScaler

# Убираем только 'country' и 'income', остальные числовые признаки оставляем
df_cluster = df.drop(columns=['country', 'income'])

# Проверим, что нужные признаки есть
print("Колонки для кластеризации:", list(df_cluster.columns))

# Масштабирование данных
scaler = StandardScaler()
df_scaled = pd.DataFrame(scaler.fit_transform(df_cluster), columns=df_cluster.columns)

print("\nДанные после масштабирования:")
print(df_scaled.head())

# 12. Кластеризация

# --- 12.1 K-means ---
print("K-means")

inertia = []
silhouette = []
K_range = range(2, 11)

for k in K_range:
    kmeans = KMeans(n_clusters=k, random_state=42)
    labels = kmeans.fit_predict(df_scaled)
    inertia.append(kmeans.inertia_)
    silhouette.append(silhouette_score(df_scaled, labels))

# Метод локтя
plt.figure(figsize=(6,4))
plt.plot(K_range, inertia, 'bo-')
plt.xlabel('Количество кластеров')
plt.ylabel('Inertia')
plt.title('Метод локтя для K-means')
plt.show()

# Силуэтный анализ
plt.figure(figsize=(6,4))
plt.plot(K_range, silhouette, 'ro-')
plt.xlabel('Количество кластеров')
plt.ylabel('Silhouette Score')
plt.title('Силуэтный анализ для K-means')
plt.show()

# Итоговая модель K-means
optimal_k = 6
kmeans_final = KMeans(n_clusters=optimal_k, random_state=42)
df['kmeans_cluster'] = kmeans_final.fit_predict(df_scaled)

print("\nКолонка 'kmeans_cluster' успешно добавлена.")
print(df[['country', 'kmeans_cluster']].head())

# --- 12.2 MiniBatch K-means ---
print("\nMiniBatch K-means")

inertia_mb = []
silhouette_mb = []

for k in K_range:
    mbk = MiniBatchKMeans(n_clusters=k, random_state=42, batch_size=20)
    labels_mb = mbk.fit_predict(df_scaled)
    inertia_mb.append(mbk.inertia_)
    silhouette_mb.append(silhouette_score(df_scaled, labels_mb))

plt.figure(figsize=(6,4))
plt.plot(K_range, inertia_mb, 'bo-')
plt.xlabel('Количество кластеров')
plt.ylabel('Inertia')
plt.title('Метод локтя для MiniBatch K-means')
plt.show()

plt.figure(figsize=(6,4))
plt.plot(K_range, silhouette_mb, 'ro-')
plt.xlabel('Количество кластеров')
plt.ylabel('Silhouette Score')
plt.title('Силуэтный анализ для MiniBatch K-means')
plt.show()

mbk_final = MiniBatchKMeans(n_clusters=optimal_k, random_state=42, batch_size=20)
df['mbk_cluster'] = mbk_final.fit_predict(df_scaled)
print("\nКолонка 'mbk_cluster' успешно добавлена.")
print(df[['country', 'mbk_cluster']].head())

# --- 12.3 Иерархическая кластеризация ---
print("\nИерархическая кластеризация")
linked = linkage(df_scaled, method='ward')

plt.figure(figsize=(20, 10))
dendrogram(
    linked,
    labels=df['country'].values,
    leaf_rotation=90,
    leaf_font_size=8,
    color_threshold=0
)
plt.title('Дендрограмма (ward)')
plt.show()

num_clusters = 4
df['hier_cluster'] = fcluster(linked, num_clusters, criterion='maxclust')
print("\nКолонка 'hier_cluster' успешно добавлена.")

# 13. Анализ кластеров и определение эталонных стран

# --- 13.1 K-means ---
cluster_summary = df.groupby('kmeans_cluster')[['child_mort', 'life_expec', 'total_fer', 'gdpp']].mean().sort_values(by='gdpp', ascending=False)
print("\nСредние значения по кластерам K-means:")
print(cluster_summary)

cluster_ethalons = []
for cluster in sorted(df['kmeans_cluster'].unique()):
    cluster_data = df[df['kmeans_cluster'] == cluster]
    cluster_data = cluster_data.assign(
        score = cluster_data['life_expec'] - cluster_data['child_mort'] - cluster_data['total_fer'] + cluster_data['gdpp']/1000
    )
    best_country = cluster_data.loc[cluster_data['score'].idxmax(), 'country']
    cluster_ethalons.append((cluster, best_country))

print("\nЭталонные страны в каждом кластере K-means:")
for c, name in cluster_ethalons:
    print(f"Кластер {c}: {name}")

# Страны, нуждающиеся в помощи (K-means)
help_countries = df[
    (df['life_expec'] < df['life_expec'].quantile(0.25)) &
    (df['gdpp'] < df['gdpp'].quantile(0.25)) &
    (df['child_mort'] > df['child_mort'].quantile(0.75))
][['country', 'child_mort', 'life_expec', 'gdpp', 'kmeans_cluster']]

print("\nСтраны, нуждающиеся в помощи (K-means):")
print(help_countries.sort_values(by='child_mort', ascending=False).head(10))

# --- 13.2 Иерархическая кластеризация ---
hier_summary = df.groupby('hier_cluster')[['child_mort', 'life_expec', 'total_fer', 'gdpp']].mean().sort_values(by='gdpp', ascending=False)
print("\nСредние значения по кластерам Hierarchical Clustering:")
print(hier_summary)

hier_ethalons = []
for cluster in sorted(df['hier_cluster'].unique()):
    cluster_data = df[df['hier_cluster'] == cluster]
    cluster_data = cluster_data.assign(
        score = cluster_data['life_expec'] - cluster_data['child_mort'] - cluster_data['total_fer'] + cluster_data['gdpp']/1000
    )
    best_country = cluster_data.loc[cluster_data['score'].idxmax(), 'country']
    hier_ethalons.append((cluster, best_country))

print("\nЭталонные страны в каждом кластере (Hierarchical):")
for c, name in hier_ethalons:
    print(f"Кластер {c}: {name}")

help_hier = df[
    (df['life_expec'] < df['life_expec'].quantile(0.25)) &
    (df['gdpp'] < df['gdpp'].quantile(0.25)) &
    (df['child_mort'] > df['child_mort'].quantile(0.75))
][['country', 'child_mort', 'life_expec', 'gdpp', 'hier_cluster']]

print("\nСтраны, нуждающиеся в помощи (Hierarchical):")
print(help_hier.sort_values(by='child_mort', ascending=False).head(10))

# --- 13.3 DBSCAN ---
# kNN-график для подбора eps
neighbors = NearestNeighbors(n_neighbors=5)
neighbors_fit = neighbors.fit(df_scaled)
distances, indices = neighbors_fit.kneighbors(df_scaled)
distances = np.sort(distances[:,4])
plt.figure(figsize=(6,4))
plt.plot(distances)
plt.xlabel('Страны')
plt.ylabel('Расстояние до 5-го соседа')
plt.title('kNN-график для выбора eps (DBSCAN)')
plt.show()

dbscan = DBSCAN(eps=2, min_samples=5)
df['dbscan_cluster'] = dbscan.fit_predict(df_scaled)
print("\nКолонка 'dbscan_cluster' успешно добавлена.")
print(df[['country', 'dbscan_cluster']].head())

dbscan_summary = df.groupby('dbscan_cluster')[['child_mort', 'life_expec', 'total_fer', 'gdpp']].mean().sort_values(by='gdpp', ascending=False)
print("\nСредние значения по кластерам DBSCAN:")
print(dbscan_summary)

help_dbscan = df[df['dbscan_cluster']==-1][['country', 'child_mort', 'life_expec', 'gdpp']]
print("\nСтраны-выбросы DBSCAN (нуждающиеся в помощи):")
print(help_dbscan.sort_values(by='child_mort', ascending=False).head(10))

# --- 14. Итоговый список стран, которым нужна помощь ---
help_countries_all = pd.concat([
    help_countries[['country']],
    help_hier[['country']],
    help_dbscan[['country']]
]).drop_duplicates()

print("\nФинальный список стран, которым помощь нужна в первую очередь:")
print(help_countries_all.sort_values(by='country').reset_index(drop=True))

# =============================
# 15. Визуализация кластеров через PCA
# =============================
from sklearn.decomposition import PCA

# Создаем 2 компоненты PCA для визуализации
pca = PCA(n_components=2)
df_pca = pd.DataFrame(pca.fit_transform(df_scaled), columns=['PC1', 'PC2'])

plt.figure(figsize=(8,6))
sns.scatterplot(x='PC1', y='PC2', hue=df['kmeans_cluster'], palette='tab10', data=df_pca, legend='full')
plt.title('K-means кластеры (PCA)')
plt.show()

plt.figure(figsize=(8,6))
sns.scatterplot(x='PC1', y='PC2', hue=df['hier_cluster'], palette='tab10', data=df_pca, legend='full')
plt.title('Иерархические кластеры (PCA)')
plt.show()

plt.figure(figsize=(8,6))
sns.scatterplot(x='PC1', y='PC2', hue=df['dbscan_cluster'], palette='tab10', data=df_pca, legend='full')
plt.title('DBSCAN кластеры (PCA)')
plt.show()

# --- Выделение стран, которым нужна помощь ---
# На графике K-means
plt.figure(figsize=(8,6))
sns.scatterplot(x='PC1', y='PC2', data=df_pca, color='lightgray', alpha=0.5)
help_idx = df.index[df['country'].isin(help_countries_all['country'])]
sns.scatterplot(x='PC1', y='PC2', data=df_pca.loc[help_idx], color='red', label='Нуждающиеся страны')
plt.title('Страны, которым нужна помощь (выделены красным, PCA)')
plt.legend()
plt.show()

"""**Комментарии по лабораторной работе**

1. Загрузка и первичный анализ данных (EDA)

- Данные содержат 167 стран и 10 признаков: country, экономические
показатели, демографические показатели и здоровье населения.

- Пропусков и дубликатов в данных нет — это облегчает дальнейший анализ.

- Были изучены распределения признаков, построены гистограммы и boxplot для выявления выбросов.

- Корреляционный анализ показал сильную взаимосвязь некоторых экономических и социальных показателей.

2. Предобработка данных для кластеризации

- Колонка country была исключена, так как она не числовая.

- Масштабированы все числовые признаки (child_mort, exports, health, imports, inflation, life_expec, total_fer, gdpp) с помощью StandardScaler для корректной работы алгоритмов кластеризации.

3. K-means и MiniBatch K-means

- Проведен анализ оптимального числа кластеров с помощью метода «локтя» и силуэта.

- Выбрано 6 кластеров.

- Рассчитаны средние показатели признаков по каждому кластеру.

- Выделены эталонные страны в каждом кластере по показателю качества жизни (life_expec - child_mort - total_fer + gdpp/1000).

- Определены страны, которым нужна помощь, по признакам: низкий GDP, низкая продолжительность жизни, высокая детская смертность.

4. Иерархическая кластеризация

- Построена дендрограмма (метод Ward).

- Выбрано 4 кластера. Рассчитаны средние показатели по кластерам и определены эталонные страны.

- Определены страны, нуждающиеся в помощи (анализ аналогичный K-means).

5. DBSCAN

- Подобраны параметры eps и min_samples с помощью kNN-графика.

- Кластеры DBSCAN рассчитаны, выбросы (cluster = -1) интерпретированы как страны с худшими показателями — приоритет для помощи.

- Рассчитаны средние показатели по кластерам.

6. Визуализация через PCA

- Снижена размерность данных до 2 компонентов для визуализации распределения стран.

- Построены scatter plots для каждого метода кластеризации.

- Красным выделены страны, которым нужна помощь, что позволяет наглядно видеть приоритетные страны.

7. Выводы и рекомендации

- Основные показатели для определения нуждающихся стран: низкий ВВП, низкая продолжительность жизни, высокая детская смертность.

- Анализ по всем методам кластеризации показал сходные результаты: большинство стран с худшими показателями находятся в одном кластере K-means, выбросы DBSCAN совпадают с ними.

- Пример стран, которым помощь нужна в первую очередь: Haiti, Sierra Leone, Chad, Central African Republic, Mali, Niger, Burkina Faso, Congo, Guinea-Bissau, Cote d’Ivoire.

- Эталонные страны для кластеров показывают, где показатели наилучшие, что полезно для сравнительного анализа.

**Итог по лабораторной**

1. Все этапы лабораторной выполнены: предобработка данных, кластеризация тремя методами, анализ кластеров, определение стран, которым нужна помощь.

2. Визуализация PCA облегчает интерпретацию кластеров и выявление приоритетных стран.

3. Полученные результаты могут быть использованы международной благотворительной организацией для выбора стран, которым нужно оказывать помощь в первую очередь.
"""